<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IFC 4D Viewer</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #infoPanel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>
    <div id="infoPanel">
        <h3>Element Info</h3>
        <p id="elementInfo">Select an element to see details.</p>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.143.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ifcjs@0.0.60/dist/ifc.min.js"></script>
    <script>
        // Configuración básica de Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Añadir una luz ambiental
        const ambientLight = new THREE.AmbientLight(0x404040, 2); // luz suave
        scene.add(ambientLight);

        // Añadir una luz direccional para sombras y resaltado
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 0.5).normalize();
        scene.add(directionalLight);

        // Configurar la cámara
        camera.position.z = 10;

        // Cargar el archivo IFC
        const loader = new IFC.Loader();
        let model;

        loader.load('Modelo4D.ifc', async function (ifcModel) {
            model = ifcModel;
            scene.add(model);

            // Procesar el IFC para extraer datos personalizados
            await parseIFCData(model);

            // Renderizar la escena
            animate();
        });

        async function parseIFCData(model) {
            const ifcManager = loader.ifcManager;

            // Recorre los elementos del modelo
            for (const mesh of model.children) {
                if (mesh.isMesh) {
                    const expressID = mesh.userData.ifcId;
                    const customData = await getCustomData(ifcManager, expressID);
                    if (customData) {
                        mesh.userData = { date: customData };
                        console.log(`Elemento ID ${expressID} - My_Data: ${customData}`);
                    }
                }
            }
        }

        async function getCustomData(ifcManager, expressID) {
            const propertySets = await ifcManager.getPropertySets(expressID);
            for (const propSet of propertySets) {
                if (propSet.Name.value === "My_Data") {
                    for (const prop of propSet.HasProperties) {
                        const propName = await ifcManager.getItemProperty(prop.value, 'Name');
                        if (propName.value === 'DATA') {
                            const dateValue = await ifcManager.getItemProperty(prop.value, 'NominalValue');
                            return dateValue.value;
                        }
                    }
                }
            }
            return null;
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Manejar el cambio de tamaño de la ventana
        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
